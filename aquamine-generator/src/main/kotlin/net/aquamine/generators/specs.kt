package net.aquamine.generators

import com.squareup.kotlinpoet.AnnotationSpec
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.STRING
import com.squareup.kotlinpoet.TypeName
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.jvm.jvmField
import com.squareup.kotlinpoet.jvm.jvmStatic

const val PACKAGE: String = "net.aquamine.api"
private const val REGISTRY_PACKAGE = "$PACKAGE.registry"
private val catalogueClassName = ClassName("net.aquamine.annotations", "Catalogue")
private val registryReference = ClassName(REGISTRY_PACKAGE, "RegistryReference")

fun TypeSpec.Builder.catalogue(parameterClassName: String): TypeSpec.Builder =
    addAnnotation(AnnotationSpec.builder(catalogueClassName).addMember("$parameterClassName::class").build())

fun TypeSpec.Builder.field(name: String, returnType: TypeName, initializer: String): TypeSpec.Builder =
    addProperty(PropertySpec.builder(name, returnType).jvmField().initializer(initializer).build())

fun TypeSpec.Builder.autoGenerated(): TypeSpec.Builder = addKdoc("This file is auto-generated. Do not edit this manually!")

fun FileSpec.Companion.catalogueType(name: ClassName): FileSpec.Builder = builder(name.packageName, name.canonicalName)
    .indent("    ")
    .addImport("net.kyori.adventure.key", "Key")
    .addImport(REGISTRY_PACKAGE, "Registries")
    .addImport(REGISTRY_PACKAGE, "RegistryReference")

fun TypeSpec.Companion.catalogueType(name: ClassName, returnType: ClassName): TypeSpec.Builder =
    objectBuilder(name).autoGenerated().catalogue(returnType.simpleName)

fun TypeSpec.Builder.registryOfMethod(returnType: TypeName, registryName: String): TypeSpec.Builder {
    return privateStaticFunction("of", registryReference.parameterizedBy(returnType)) {
        addParameter("name", STRING)
        addCode("return·RegistryReference.of(Registries.$registryName,·Key.key(name))")
    }
}

fun <T> TypeSpec.Builder.catalogueField(field: CollectedField<T>, returnType: TypeName, keyGetter: KeyGetter<T>): TypeSpec.Builder =
    field(field.name, registryReference.parameterizedBy(returnType), "of(\"${keyGetter.key(field).path}\")")

inline fun TypeSpec.Builder.privateStaticFunction(
    name: String,
    returnType: TypeName,
    builder: FunSpec.Builder.() -> Unit = {}
): TypeSpec.Builder = addFunction(FunSpec.builder(name).addModifiers(KModifier.PRIVATE).returns(returnType).jvmStatic().apply(builder).build())
